# 读取文件内容返回字符串

## 一、targets：
1. 读取上传文件的内容，并返回文本字符串

<br><br><br>

## 二、路由
```
/public/upload_file2string
```
request (form-data):<br>
key: file, <br>value: 上传的文件

response (json):<br>
success
```json
{
    "status": 0,
    "msg": "已读取",
    "data": {
        "language": "Python",
        "fileContent": "import json\r\nimport os\r\nimport shutil\r\nimport uuid\r\nimport zipfile\r\nfrom datetime import timedelta, datetime\r\n\r\nimport chardet\r\n\r\nfrom django.http import FileResponse, HttpResponse\r\nfrom django.http import JsonResponse  # 返回json格式\r\nfrom django.shortcuts import render\r\nfrom django.utils import timezone\r\nfrom django.views.decorators.csrf import csrf_exempt\r\nfrom django.views.decorators.http import require_POST, require_GET\r\n\r\nfrom ccanalyzer import extract\r\nfrom ccanalyzer import process\r\nfrom ccanalyzer import tool\r\nfrom code_comment_analyzer.settings import BASE_DIR\r\nfrom public.models import DeletionTask\r\nfrom user.models import User, OperatingRecord, FileRecord, ProjectRecord\r\n\r\n\r\n# --------------\r\n# yaml自定义配置\r\nimport yaml\r\nwith open(BASE_DIR / 'configs.yaml', 'r', encoding='utf8') as file:\r\n    configs = yaml.safe_load(file)\r\n# ---------------\r\n\r\n\r\n# 这块返回的是静态页面\r\n# ----------------------------------------------------------------\r\n# ----------------------------------------------------------------\r\n# 首页 get\r\n@require_GET\r\ndef index(request):\r\n    page = os.path.join('static', 'index.html')\r\n    return FileResponse(open(page, 'rb'))\r\n\r\n\r\n# 文件页面 get\r\n@require_GET\r\ndef file(request):\r\n    page = os.path.join('static', 'file.html')\r\n    return FileResponse(open(page, 'rb'))\r\n\r\n\r\n# 项目页面 get\r\n@require_GET\r\ndef project(request):\r\n    page = os.path.join('static', 'project.html')\r\n    return FileResponse(open(page, 'rb'))\r\n\r\n\r\n# 说明文档页面 get\r\n@require_GET\r\ndef readme(request):\r\n    page = os.path.join('static', 'readme.html')\r\n    return FileResponse(open(page, 'rb'))\r\n\r\n# 返回说明文档内容\r\n@require_GET\r\ndef get_readme(request):\r\n    # 指定 markdown 文件的路径\r\n    markdown_file_path = os.path.join('static', 'readme.md')\r\n\r\n    # 读取 markdown 文件内容\r\n    try:\r\n        with open(markdown_file_path, 'r', encoding='utf-8') as file:\r\n            markdown_content = file.read()\r\n    except FileNotFoundError:\r\n        return JsonResponse({\r\n            'status': 1,\r\n            'msg': 'README file not found',\r\n            'data': ''\r\n        }, status=404)\r\n    except Exception as e:\r\n        return JsonResponse({\r\n            'status': 1,\r\n            'msg': f'Error reading README file: {str(e)}',\r\n            'data': ''\r\n        }, status=500)\r\n\r\n    # 检查查询参数以决定返回格式\r\n    if request.GET.get('format') == 'markdown':\r\n        # 返回纯 markdown 文本\r\n        response = HttpResponse(markdown_content, content_type='text/markdown')\r\n    else:\r\n        # 返回 JSON 格式\r\n        response = JsonResponse({\r\n            'status': 0,\r\n            'msg': '',\r\n            'data': markdown_content\r\n        })\r\n\r\n    return response\r\n\r\n\r\n# 登录页面 get\r\n@require_GET\r\ndef login(request):\r\n    page = os.path.join('static', 'login.html')\r\n    return FileResponse(open(page, 'rb'))\r\n\r\n# 注册页面 get\r\n@require_GET\r\ndef sign_up(request):\r\n    page = os.path.join('static', 'sign_up.html')\r\n    return FileResponse(open(page, 'rb'))\r\n\r\n# 错误页面\r\ndef custom_404(request, exception=None):\r\n    page = os.path.join('static', '404.html')\r\n    return FileResponse(open(page, 'rb'))\r\n# ----------------------------------------------------------------\r\n\r\n\r\n# 这块返回的是处理的理由\r\n# ----------------------------------------------------------------\r\n# ----------------------------------------------------------------\r\n# 单文件上传转字符串\r\n\"\"\"\r\n    上传的内容：{\r\n        \"file\":    # 上传的文件\r\n    }\r\n\r\n    返回内容：{\r\n        \"status\": 0, # 返回 0，表示当前接口正确返回，否则按错误请求处理；\r\n        \"msg\": \"\",   # 返回接口处理信息，主要用于表单提交或请求失败时的 toast 显示；\r\n        'data': {\r\n            \"language\":  ,               # 语言类型\r\n            \"fileContent\": fileContent,  # 文件的内容\r\n        }     \r\n    }\r\n}\r\n\"\"\"\r\n@csrf_exempt\r\n@require_POST\r\ndef upload_file2string(request):\r\n    fileContent = \"\"\r\n\r\n    # 获取上传的文件\r\n    uploaded_file = request.FILES.get('file')\r\n\r\n    if uploaded_file:\r\n        # 判断文件类型\r\n        language = tool.detect_language(uploaded_file.name)\r\n\r\n        # 检测文件编码\r\n        raw_data = uploaded_file.read()\r\n        result = chardet.detect(raw_data)\r\n        encoding = result['encoding']\r\n\r\n        # 使用检测到的编码进行解码\r\n        fileContent = raw_data.decode(encoding, errors='replace')\r\n\r\n        # --------------------------------------\r\n        # 用户存储部分\r\n        # 检查用户是否登录\r\n        user_id = request.session.get('user_id')\r\n        if user_id:\r\n            try:\r\n                user = User.objects.get(uid=user_id)\r\n\r\n                # 创建操作记录\r\n                operating_record = OperatingRecord.objects.create(\r\n                    user=user,\r\n                    operation_type='文件上传'\r\n                )\r\n\r\n                # 创建文件记录\r\n                FileRecord.objects.create(\r\n                    operating_record=operating_record,\r\n                    file_content=fileContent,\r\n                    file_type=language\r\n                )\r\n\r\n            except User.DoesNotExist:\r\n                return JsonResponse({\r\n                    'status': 1,\r\n                    'msg': '用户不存在',\r\n                    'data': {}\r\n                }, status=404)\r\n        # --------------------------------------\r\n\r\n        return JsonResponse({\r\n            'status': 0,\r\n            \"msg\": \"已读取\",\r\n            'data': {\r\n                \"language\": language,\r\n                \"fileContent\": fileContent\r\n            }\r\n        })\r\n    else:\r\n        return JsonResponse({\r\n            'status': 0,\r\n            \"msg\": \"未接收到文件\"\r\n        }, status=400)\r\n\r\n\r\n# 处理单个文件 post\r\n\"\"\"\r\n    上传的内容：{\r\n        \"fileType\":    C C++ Python Java Golang HTML CSS JavaScript\r\n        \"fileContent\": 文件内容文本\r\n    }\r\n    \r\n    返回内容：{\r\n        \"status\": 0, # 返回 0，表示当前接口正确返回，否则按错误请求处理；\r\n        \"msg\": \"\",   # 返回接口处理信息，主要用于表单提交或请求失败时的 toast 显示；\r\n        \"data\": {    # 必须返回一个具有 key-value 结构的对象。\r\n            ...其他字段\r\n        }\r\n    }\r\n}\r\n\"\"\"\r\n@csrf_exempt\r\n@require_POST\r\ndef analyze_file(request):\r\n    try:\r\n        # 获取请求的JSON数据\r\n        body_unicode = request.body.decode('utf-8')\r\n        data = json.loads(body_unicode)\r\n        language = data.get('language')  # 目标\r\n        file_content = data.get('fileContent')  # 目标\r\n\r\n        # print(language)\r\n        # print(file_content)\r\n        # 检查请求数据的有效性\r\n        if not language or not file_content:\r\n            return JsonResponse({\r\n                'status': '0',\r\n                'message': 'Invalid input'\r\n            }, status=400)\r\n\r\n    except (UnicodeDecodeError, json.JSONDecodeError) as e:\r\n        return JsonResponse({\r\n            'status': '0',\r\n            'message': 'Invalid input format'\r\n        }, status=400)\r\n\r\n    if language == \"Unknown\":\r\n        return JsonResponse({\r\n            'status': '0',\r\n            'message': '仅限语言C/C++、Python、Java、Golang、HTML、CSS、JavaScript'\r\n        }, status=400)\r\n\r\n    # print(language)\r\n    # 根据文件类型和内容进行相应的分析\r\n    codeExtract = extract.PythonCommentExtractor()\r\n    if language == \"Python\":\r\n        codeExtract = extract.PythonCommentExtractor()\r\n    if language == \"C\":\r\n        codeExtract = extract.CCppCommentExtractor()\r\n    if language == \"C++\":\r\n        codeExtract = extract.CCppCommentExtractor()\r\n    if language == \"Java\":\r\n        codeExtract = extract.JavaCommentExtractor()\r\n    if language == \"Golang\":\r\n        codeExtract = extract.GoCommentExtractor()\r\n    if language == \"HTML\":\r\n        codeExtract = extract.HTMLCommentExtractor()\r\n    if language == \"CSS\":\r\n        codeExtract = extract.CSSCommentExtractor()\r\n    if language == \"JavaScript\":\r\n        codeExtract = extract.JavaScriptCommentExtractor()\r\n\r\n    ceResult = codeExtract.extract_comments(file_content)\r\n\r\n    processedJson = process.Json(ceResult)\r\n\r\n    analyze_data = processedJson.getJson(configs[\"Ccanalyzer\"][\"maxNum\"])\r\n\r\n    # 转换换行符号位html符号\r\n    for i in range(len(analyze_data['multiLineComments'])):\r\n        analyze_data['multiLineComments'][i] = analyze_data['multiLineComments'][i].replace(\"\\n\", \"<br>\").replace(\" \", \"&nbsp;\")\r\n    # print(analyze_data['multiLineComments'])\r\n\r\n    # 返回处理后的数据\r\n    return JsonResponse({\r\n        'status': 0,\r\n        \"msg\": \"已分析\",\r\n        \"language\": language,\r\n        'data': analyze_data\r\n    })\r\n\r\n\r\n# 上传项目压缩包，并且返回树形结构\r\n@csrf_exempt\r\n@require_POST\r\ndef upload_and_get_tree(request):\r\n\r\n    # 从请求中获取上传的文件\r\n    uploaded_file = request.FILES.get('file')\r\n\r\n    # 如果没有文件上传，返回错误响应\r\n    if not uploaded_file:\r\n        return JsonResponse({\r\n            'status': 0,\r\n            'message': 'No file uploaded'\r\n        }, status=400)\r\n\r\n    # --------------------------------------\r\n    # 用户存储部分\r\n    # 检查用户是否登录\r\n    user_id = request.session.get('user_id')\r\n    if user_id:\r\n        try:\r\n\r\n            # 生成一个唯一的目录名\r\n            unique_dir = BASE_DIR / f'media/projects/user{user_id}' / str(uuid.uuid4())\r\n            # 创建该目录\r\n            unique_dir.mkdir(parents=True, exist_ok=True)\r\n\r\n            # 存储上传的文件\r\n            file_path = os.path.join(unique_dir, uploaded_file.name)\r\n            with open(file_path, 'wb+') as destination:\r\n                for chunk in uploaded_file.chunks():\r\n                    destination.write(chunk)\r\n\r\n            # 设置解压后的文件存放路径，以压缩文件的名称（去掉扩展名）作为目录名称\r\n            extracted_path = unique_dir / 'extracted' / uploaded_file.name.split('.')[0]\r\n            extracted_path.mkdir(parents=True, exist_ok=True)  # 确保目录存在\r\n            # print(extracted_path)\r\n\r\n            # 使用 zipfile 模块解压文件到目标路径\r\n            with zipfile.ZipFile(file_path, 'r') as zip_ref:\r\n                zip_ref.extractall(extracted_path)\r\n\r\n            # 调用 get_directory_tree 函数生成文件目录树\r\n            tree = tool.get_directory_tree(extracted_path)\r\n\r\n            # 删除解压后的压缩包\r\n            os.remove(file_path)\r\n\r\n            # 存储操作记录和项目记录\r\n            user = User.objects.get(uid=user_id)\r\n            operating_record = OperatingRecord.objects.create(\r\n                user=user,\r\n                operation_type='项目上传'\r\n            )\r\n\r\n            ProjectRecord.objects.create(\r\n                operating_record=operating_record,\r\n                project_url=unique_dir\r\n            )\r\n\r\n            # 返回 JSON 响应，包含文件目录树\r\n            return JsonResponse({\r\n                'status': 0,\r\n                'message': '文件已解压',\r\n                'data': tree})\r\n\r\n        except User.DoesNotExist:\r\n            return JsonResponse({\r\n                'status': 1,\r\n                'msg': '用户不存在',\r\n                'data': {}\r\n            }, status=404)\r\n    # --------------------------------------\r\n\r\n    else:\r\n        # 生成一个唯一的目录名\r\n        unique_dir = BASE_DIR / 'media/temp/projects' / str(uuid.uuid4())\r\n        # 创建该目录\r\n        unique_dir.mkdir(parents=True, exist_ok=True)\r\n\r\n        # 存储上传的文件到 'uploads' 目录下\r\n        # 拼接文件路径并保存文件\r\n        # 使用唯一目录保存文件\r\n        file_path = unique_dir / uploaded_file.name\r\n        with open(file_path, 'wb+') as destination:\r\n            for chunk in uploaded_file.chunks():\r\n                destination.write(chunk)\r\n\r\n        # 设置解压后的文件存放路径，以压缩文件的名称（去掉扩展名）作为目录名称\r\n        extracted_path = unique_dir / 'extracted' / uploaded_file.name.split('.')[0]\r\n        extracted_path.mkdir(parents=True, exist_ok=True)  # 确保目录存在\r\n        # print(extracted_path)\r\n\r\n        # 使用 zipfile 模块解压文件到目标路径\r\n        with zipfile.ZipFile(file_path, 'r') as zip_ref:\r\n            zip_ref.extractall(extracted_path)\r\n\r\n        # 调用 get_directory_tree 函数生成文件目录树\r\n        tree = tool.get_directory_tree(extracted_path)\r\n\r\n        # 删除解压后的压缩包\r\n        os.remove(file_path)\r\n\r\n        # 返回 JSON 响应，包含文件目录树\r\n        return JsonResponse({\r\n            'status': 0,\r\n            'message': '文件已解压',\r\n            'data': tree},)\r\n        # return JsonResponse({'status': 'success', 'tree': \"file_path\"})\r\n\r\n# 通过文件路径读取文件内容返回\r\n@csrf_exempt\r\n@require_POST\r\ndef read_file(request):\r\n    try:\r\n        # 从 POST 请求体中解析 JSON 数据\r\n        data = json.loads(request.body)\r\n        # 从解析后的 JSON 数据中获取文件路径\r\n        file_path = data.get('path')\r\n    except json.JSONDecodeError:\r\n        # 如果 JSON 数据解析失败，返回错误响应\r\n        return JsonResponse({\r\n            'status': 0,\r\n            'message': '无效JSON数据'\r\n        }, status=400)\r\n\r\n    # 文件路径为空，表示没有选择文件\r\n    if not file_path:\r\n        return JsonResponse({\r\n            'status': 0,\r\n            'message': '请要上传的选择文件'\r\n        }, status=404)\r\n\r\n    # 检查文件路径是否有效\r\n    if not os.path.exists(file_path):\r\n        # 如果文件路径无效，返回错误响应\r\n        return JsonResponse({\r\n            'status': 0,\r\n            'message': '文件不存在'\r\n        }, status=404)\r\n\r\n    language = tool.detect_language(file_path)\r\n    if language == \"Unknown\":\r\n        return JsonResponse({\r\n            'status': 1,\r\n            'msg': '暂不支持此类文件',\r\n            'data': {}\r\n        }, status=404)\r\n\r\n    # 打开文件并读取其内容\r\n    # 检测文件编码\r\n    with open(file_path, 'rb') as file:  # 以二进制模式打开文件用于检测编码\r\n        raw_data = file.read(5000)  # 读取文件的前 5000 字节来检测编码\r\n    result = chardet.detect(raw_data)\r\n    encoding = result['encoding']\r\n\r\n    # 使用检测到的编码读取文件\r\n    with open(file_path, 'r', encoding=encoding, errors='replace') as file:\r\n        content = file.read()\r\n\r\n    # 返回成功响应，包含文件内容\r\n    return JsonResponse({\r\n        'status': 0,\r\n        'message': '内容读取成功',\r\n        'language': language,\r\n        'data': {\r\n            'fileContent': content\r\n        }})\r\n\r\n\r\n@csrf_exempt\r\n@require_POST\r\ndef test(request):\r\n    return JsonResponse({\r\n    \"status\": 0,\r\n    \"msg\": \"已分析\",\r\n    \"data\": {\r\n        \"commentLines\": 20,\r\n        \"codeLines\": 48,\r\n        \"commentDensity\": 0.4166666666666667,\r\n        \"lenWordsBefore\": 39,\r\n        \"wordsBefore\": {\r\n            \"的\": 7,\r\n            \"内容\": 4,\r\n            \"文件\": 3,\r\n            \"返回\": 3,\r\n            \"处理\": 3,\r\n            \"数据\": 3,\r\n            \"请求\": 2,\r\n            \"页面\": 1,\r\n        },\r\n        \"lenWordsAfter\": 32,\r\n        \"wordsAfter\": {\r\n            \"内容\": 4,\r\n            \"文件\": 3,\r\n            \"返回\": 3,\r\n            \"数据\": 3,\r\n            \"请求\": 2,\r\n            \"页面\": 1,\r\n        },\r\n        \"singleLineComments\": [\r\n            \" 文件页面 get\",\r\n            \" 这块返回的是处理的逻辑\",\r\n            \" ----------------------------------------------------------------\",\r\n            \" ----------------------------------------------------------------\",\r\n            \" 处理单个文件 post\",\r\n            \" 获取请求的JSON数据\",\r\n            \" 检查请求数据的有效性\",\r\n            \" 根据文件类型和内容进行相应的分析\",\r\n            \" 返回处理后的数据\"\r\n        ],\r\n        \"multiLineComments\": [\r\n            \"\\n    上传的内容：{\\n        \\\"fileType\\\":    C C++ Python Java Golang HTML CSS JavaScript\\n        \\\"fileContent\\\": 文件内容文本\\n    }\\n\\n    返回内容：{\\n        \\\"status\\\": \\n        \\\"analyzeData\\\":\\n    }\\n\"\r\n        ]\r\n    }\r\n})\r\n\r\n\r\n# ----------------------------------------------------------------\r\n# ----------------------------------------------------------------\r\n# 定期删除任务\r\n# def perform_deletion_tasks():\r\n#     tasks = DeletionTask.objects.all()  # 获取所有删除任务\r\n#     now = timezone.now()  # 获取当前时间\r\n#\r\n#     for task in tasks:\r\n#         # 如果任务从未运行或自上次运行以来已过了指定的天数\r\n#         if task.last_run is None or (now - task.last_run).days > task.max_age_days:\r\n#             # 如果指定路径存在\r\n#             if os.path.exists(task.path):\r\n#                 cutoff_date = now - timedelta(days=task.max_age_days)  # 计算过期时间\r\n#                 for item in os.listdir(task.path):\r\n#                     item_full_path = os.path.join(task.path, item)\r\n#                     if os.path.isdir(item_full_path):\r\n#                         # 检查目录修改时间是否早于过期时间\r\n#                         mtime = timezone.make_aware(datetime.fromtimestamp(os.path.getmtime(item_full_path)))\r\n#                         if mtime < cutoff_date:\r\n#                             shutil.rmtree(item_full_path)  # 删除过期目录\r\n#                             print(f\"Deleted {item_full_path}\")\r\n#\r\n#             # 更新任务的最后运行时间\r\n#             task.last_run = now\r\n#             task.save()\r\n\r\n\r\n"
    }
}

```
failure
```json
"language": "Unknown"
```
